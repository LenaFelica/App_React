//* --*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
//* Услоная отрисовка:
// {sortAndSearchPosts.length !== 0
//    ? <PostList remove={removePost} posts={sortAndSearchPosts} title="Список постов по JavaScript"/>
//    : <h1 style={{textAlign: 'center'}}>Посты не найдены!</h1>
//  }      

import { getPagesArray } from "./utils/pages";

//* получаем данный из управляемого инпута:
// const[title, setTitle] = useState('');
// const[body, setBody] = useState('');


//* инпутов может быть много - создаем состояние post и помещаем туда объект с title и body
//* инициализируем их сразу пустыми строками
//* а в onChange - передаем объект в setPost - разворачиваем тарые посты и перезатераем нужное для насс поле
//* то есть. еще раз, мы изеняем нужное для нас поле, а весь остальной объек оставляем в неизменном виде
//* добавим id - он должен быть всегда уникальный - егополучим из текущей даты!!
//* e.preventDefault(); //проедотвращаем дефолтное поведение браузера(когда при нажатии на кнопку страница оновляетсяя и данные уходят на сервер, так как тип у кнопки submit)
//   const newPost = { - эта переменная теперь не нужна - разворачивае в setPosts вместо newPost развернем ...post, и добавим id
//      id: Date.now(), - 
//      title,
//      body,
//   }

     //!  ***   запомнить НАВСЕГЛА  - важно!! - добавление нового поста - развернуть старый массив и добавить новый пост
   //   setPosts([...posts, {...post, id: Date.now()}]) // добавляем ссозданный объект в массив постов - не изменем состояние напрямую, вызываем setPosts и передаем туда новый массив [], куда разворачиваем старый массив с постами и добавяем новый ерез запятую
   //   setTitle('') // после добавление очиаем поле ввода в инпуте для тайтла
   //   setBody('') // после добавление очиаем поле ввода в инпуте для боди
   //   setPost({title:'' , body: ''}) // теперь очищение формы после добавления посста так делаем
//* и так как мы реализоали двустороннее связывание, то инпуты при таком повдении у нас очистятся - компонент управляяемы
//
//* Так ниже мы будем проверять, если постов нет - длины постов нет - то мы будем выводить надпись - ПОСТЫ не найдены!


//*-----------------------------------------------------
//* Создаем функцию сортировки sortPosts чтобы вызвать ее в onChange
//* но мы не можем напрямую сортировать, так как метод сорт мутирует исходный массив
//* поэтому , мы разворачивае с помощь spread исходный массив постов, а таким образом мы его копируем
//* и сортируем уже копию
//* для сравнения строк используетс localeCompare()
//* setPosts([...posts].sort(a,b) => a[sort].locleCompare(b[sort]))
//* сравниваем поле из объекта а с полем из объекта b
//* Реализуем поиск searchQuery в MyInput
//* Для того чтобы удалять ненужные
//* При этом нужно реализовать фильтрацию !!
//* Механизм сортировки переносится в const sortedPosts
//*[...posts].sort((a,b) => a[sort].localeCompare(b[sort])))
//* но там уже не просто sort используем, а само состояние selectedSort
//* и в компонент PostList будем передавать не просто ссостояние
//* а уже отсортированный массив постов - эту функцию sortedPosts
//
//* так как selectedSort  - это пустая строка, то подобная соритировка не отработает
//* так как мы оращаемся к пустому полю и выдаст undwfined 
//* мы пытаемся получить несуществующщее поле и вызываем у его ф-ю localeCompare()
//* а этого поля нет, мы получаем undefined, и соответствено пытаемся вызвать ф-ю у андефайнед
//
//* поэтому надо создать ф-ю - getSortedPosts() - и проверять
//* если selectedSort существует , если там не пустая строка
//* то мы будем возвращать отсортированны массив
//* в обратном случае просто массив постов posts
//* а в ф-ю sortedPosts мы помещаем результат getSortedPosts
//* функция sortedPosts отрабатывает
//* но если что-то написать в инпут, то на каждый ввод символа эта функция вызывается
//* на каждый рендер
//* такое нас не устраивает, если массив состоит из 1000 элементов, то это жуткий удар попроизводительности
//
//* ПОЭТОМУ!!! 
//! *** useMemo(callback, deps) **
//*колбэк должен возвращать результат каки-то выислний
//*например, отсортированный или отфильтрованный массив, какие-то математич вычисления
//* в массив зависимостей передавать переменные, поля объекта
//useMemo(() => {
//    return [...posts].sort(...)
// }, [selectedSot, posts])
// Для его это хук?
//* Производит вычисление, запоминает результат и кеширует!
//* Это называется Мемоизация
//* И на каждую перерисовку компонента, она не ортирует массив вновь, пересчитывает заново
//* Достает отсортированный массив из кеша
//* Но каждый раз когда какая-либо из зависимотей менятся
//* Например, мы выбрали другой режим сортировки - функци вновь персчитывает и кеширует новый результат
//* До тех пор, пока опять одна из зависимостей не изменится
//* Если массив зависимостей путой. то функция отработает лишь единожды. запомнит результат и болье вызвана ен будет!!!
//* кобэ будет взван в том случае, когда какая-то из зависимостей поменяет значени
//
//!  **** Реализуем поиск! *** sortAndSearhPosts - 
//* на основании отсортированного массива мы и можем деать поиск!
//
//* useMemo() - в массв заисимостей будет попадать поисковая строка и отсортированный массив
//* [seachQuery, sortedPosts]
//* Сейчас в компоннт POstList будем передавать и отсортированный и отфильтрованный массив sortAndSearchPosts
//* то есть, одовременно будет работать и поиск и сортировка
//* из колбэка внутри UseMemo мы долны вернуть результат каких-либо вычислений
//* здесь мы должны отфильтровать массив по поисковой строке - есть там что-то или нет
//* выделяем каждый пост, поле title.includes(seachQuery)
//* то есть вводим в поисковик необходимый пост, а он нам показывает есть среди постов такой или нет
//*
//*Реализовала поиск - с фукцией toLowerCase() тобы игнорировать регистр
// const sortAndSearchPosts = useMemo(() => {
//    return sortedPosts.filter((post) => post.title.toLowerCase().includes(searchQuery.toLowerCase()))
// }, [searchQuery, sortedPosts])
//
//* Если по поиску ни одного посста не находится, должна появляться надиссь - посты не надены
//* поэтому, услови для такой надписи надо делать дл sortAndSearchPosts.length
//* если есть, то делать отрисовку PostList
//* если нет. то надпиь - посты не найдены!
//
//!  PostFilter.jsx - отвечает за манипулции над списком постов
//* Будет отвечать за сортировки, за фильтрации
//* помимо поиска модно придумать еще кучу фильтров, все сюда
//* Далее декомпозиция - выделение сортировки и фильтрации в PostFilter()
//* и в него идет сортировка и поиск MyInput MySelect
//
//*создали PostFilter и создаем в Арр новое состояние [filter, setFilter]
//* вместо этого, что ниже
// //*создаем состояние для сортировки
// const [selectedSort, setSelectedSort] = useState('');  

// //*делаем MyInput дл поиска постов управляемым
// const[searchQuery, setSearchQuery] = useState('')
//
//* const[filter, setFilter] = useState({sort: '', query:''})
//* sort - алгоритм сортировки
//* query - поисковая строка
//
//* При этом, состояни selectedSort и seachQuery удаляем и заменяем на filter
//* Инициализируя его объектом ({sort:'', query:''})
//* И поскольку состояния selectedSort и seachQuery удалили,
//* внесем правки и заменим их в колбэках у  useMemo() на filter.sort и filter.query
//
//* Функция для получения постов и проверка, есть ли они, тогда сортировка
//
// const sortedPosts = useMemo(() => {
//    if(filter.sort) {
//      return [...posts].sort((a, b) => a[filter.sort].localeCompare(b[filter.sort]))
//    } else {
//       return posts
//    }
// }, [filter.sort, posts])

// const sortAndSEarchPosts = useMemo(() => {
//    return sortedPosts.filter((post) => post.titile.toLowerCase().includes(filter.query.toLowerCase()))
// }, [filter.query, sortedPosts])
//
//* Сейчас есть форма для создания, для фильтрации и список
//
//! Это называетс Услова отрисовка!!
// {posts.length - длина постов есть(посты есть)
//    ? <PostList remove={removePost} posts={posts} title="Список постов по JavaScript"/>
//    : <h1 style={{textAlign: 'center'}}>Посты не найдены!</h1>
//  }
//
//*переносим условную отрисовку в сам список постов <PostList />
//
//! **** Всплывающее Модальное окно  ****
//
//* Переносим форму для создания поста в модальное окно


//*!  *** Анимация - react-transition-group 
//* устанавливается пакет
//* например, сдлеать. чтобы посты заезжали и выезжали
//npm install react-transition-group --save
//* можно реанимировать списки, отслеживать фазы анимации
//
//* Открываем PostList и завернем его в TransitionGroup
//
//! ** переходим к кастомным хукам!
//* логику по сортировки и фильтации выносим в usePosts.js
//* кастомные хуки всегда начинаются с use и расширение имеют js
//* сразу экспортируются
////* сортировка с состоянием - переносится в кастомный хук usePosts.js
// const sortedPosts = useMemo(() => {
//    console.log('отработала функция сортед постс')
//    if(filter.sort) {
//       return  [...posts].sort((a,b) => a[filter.sort].localeCompare(b[filter.sort]))
//    } else {
//      return posts;
//    }
// },[filter.sort, posts])

//* Логика переносится в катомный хук usePosts!!^::
// const sortAndSearchPosts = useMemo(() => {
//     return sortedPosts.filter((post) => post.title.toLowerCase().includes(filter.query.toLowerCase()))
// }, [filter.query, sortedPosts]
//* Кастомные хуи - это хуки, которые на верхнем уровне
//* испольльзуют сандартные реакт хуи(useState, useMemo)
//* export const useSortedPosts = (posts, sort)=>{} - параметрами будет ринимать посты и метод ссортировки
//
//* Логика готова уже - это вся логика с useMemo!!
//* берем ее из Арр и переносим in usePosts
//* так как функция принимает sort, то filter уже не нужен
//? const sortedPosts = useMemo(() => {
//?    console.log('отработала функция сортед постс')
//?    if(filter.sort) { //sort
//?       return  [...posts].sort((a,b) => a[filter.sort].localeCompare(b[filter.sort])) // и здесь просто sort
//?    } else {
//?      return posts;
//?    }
//? },[filter.sort, posts]) //sort

//* по итогу у нас есть хук, коорый что-то сортирует и по итогу отсортированный массив должен вернуть
//
//* Хук по сортировки готов:
// import { useMemo } from "react";

// export const useSortedPosts = (posts, sort) => {
//    const sortedPosts = useMemo(() => {
//       console.log('отработала функция сортед постс')
//       if(sort) {
//          return  [...posts].sort((a,b) => a[sort].localeCompare(b[sort]))
//       } else {
//         return posts;
//       }
//    },[sort, posts])

//    return sortedPosts;
// }
//
//* Ниже создаем еще один - usePosts - он будет возвращать уже и отфильтрованный, и отортированный массив постов
//
// export const usePosts = (posts, sort, query) => {
//    //* получим масив отсортированных постов:
//    const sortedPosts = useSortedPosts(posts, sort)

//    const sortAndSearchPosts = useMemo(() => {
//       return sortedPosts.filter((post) => post.title.toLowerCase().includes(query.toLowerCase()))
//   }, [query, sortedPosts])
  
//    return sortAndSearchPosts;
// }

//
//* таким образомб получился хук usePosts.js, который и сортирует и фильтрует
//* осталось вызвать его внутри компонента Арр
//* а в Арр сделали декомпозицию и логику вынесли, стало меньше на 15 строчек кода

//*Стили для модального окна
// .myModal {
//    position: fixed;
//    lft:0;
//    right:0;
//    bottom:0;
//    top:0
//    display:none
//    background: rgba(0,0,0, 0.5)
// }

// myModal.content{
//    padding:25px;
//    background: white;
//    border-radius: 16px;
//    min-width: 250
// }

// .myModal.active {
//    display:flex;
//    jcsb  
//    aic
// }

//import cl from "./MyModal.module.css"
// const MyModal = ({children, visible, setVisible}) => {

//    const root = [cl.myModal]
//    if(visible) {
//       root.push(cl.active)
//    }

//    return(
//       <div className={root.join(' ')} onClick = {() => setVisible(false) }>
//          <div classNme={cl.myModalContent} onClick={(e) => e.stopPropagation()}>
//             {children}
//          </div>
//       </div>
//    )
// }
//
// App
//
// Состояние - видимо модальное окно или нет
// const [modal, setModal] = useState(false)

// <MyButton style={{marginTop: 30}}onClick={() => setModal{true}}>
//    Добавить пост
// </MyButton> 
// <MyModal 
//  visible={modal}
//  setVisible={setModal}
// >
 //  <PostForm create={createPost} />
//</MyModal> 
//*
//* Чтобы закрывалась модалка после добавления поста
//* в createPost добавить setModal(false)
// const createPost = (newPost) => {
//    setPosts([...posts, newPost])
//    setMdal(false) //сетим в остояние false
// }

//! ****   работа с серверо AXIOS  ***
//
//* jsonplaceholder.typicode.com
//* JSON{Placeholder} - позволяет получать некоторое кол-во данных
//* то еть . мы отправляем запро и получаем объекты, массивы
//* есть наор эндпоин - адресов, с пом которых мы получаем данные
//* нас интересуют посты
//* в разделе Resources 
// https://jsonplaceholder.typicode.com/posts
//* копируем эту ссылку 
//*идля того, чтобы делать запросы, понадобится библтотека axios
//* npm i axios
//* устанавливаем
//* теперь реализуем функцию. котора будет отправлять запрос на сервер, 
//* получать данные и помещать их в состояние с постами
//* вместо fetch используем axios !!!! - это у нас get запрос
// async function fetchPosts () {
//    const response = await axios.get('https://jsonplaceholder.typicode.com/posts')
//    setPosts(response.data)
// }
// <yButton onMCliick={fetchPosts}>Get Post</yButton>
// по нажатию на кнопку в консоле
//{data: Array(100), status: 200, statusText: '', headers: AxiosHeaders, config: {…}, …}
//нас итересует как раз 100 постов
//* консоль убираем и помещаем результат с постами в состояние
//* добавили резал  setPosts(response.data)
//* нажимаем на кнопку getpost и загружаютс на странице все 100 постов
//* 
//* сейчас мы подгружаем посты принажатии на кнопку
//* а надо. чтобы они сами подгружались при первичной отрисовки приложения
//
//! *** хук useEffect(callback, dept) ***
//
//* Наблюдает за жизненым циклом компонента
//
//* Жизненный цикл компонента:

//* Монтирование(mount) - создается компонент и вмонтируется в дом дерево
//* - первичная подгрузка данных
//* - повесить какие-то слушатели события
//
//* Обновление(update) - стадия активной жизни компонента - изменили состояние - происходит апдейт
//* - следить за изменениями каких-либо зависимостей
//* -

//* размонтирование(unmount) -
//*- очищение глобального хранилища, 
//* - отписывание от событий
//
//* useEffect используетс в одном компоненте сколько надо 
//* один хук за первичную отрисовку, другой за изменениями, третий за удалением
//
//* Стадия монтирования:
//* При первичной загрузке массив зависимости пустой,
//* колбэк отработает лишь единожды и больше вызвани не будет
//* посты подгузутся
//
//* Стадия обновления:
//* Чтобы следить за изменениями, нужно добавить объекты в массив зависимости
//* мы будем следить за объектом filter, и какждый раз. когда он изменяестя, будет отрабатывать колбэк, который мы передали в useEffect()
//
//* Стадия размонтирования:
//* Если колбэк возвращает какую-либо функцию, то она вызовется в момент демонтирования компонента 
//* Очистки, отписки и тд

// const getPosts = useEffect(() => {
//    fetchPosts()
// }, [])
//
//* Далее, делаем ручку. за котрую можно дернцть и полуить массив постов
//
//*!  ****   Создаем папку API ***
//* в ней PostService.js
//
//* вынесем получение постов в отдельный файл!!
//* создадим клас и в ней татичная асинхронная функция, 
//* которая будет возвращать список постов
//* и переносим запрос в axios.get в нее
//* и по итогу из этой функции будем возвращать массив посто retun response.data
//* можно отловить ошику, но подже изменим - на уровне сервера делать это не хорошо
// export default class PostService {
//    static async getAll(){
//        const response = await axios.get('https://jsonplaceholder.typicode.com/posts')
//        return response.data;
//}
// }
//* в Арр в функции fetchPosts вместо axios.get обращаемся к PostService.getAll()

//
//*! *****  isPostsLoading **** индикатор загрузки - крутилка
//
//* Создаем состояние и по умолчанию оно false
//const [isPostsLoading, setIsPostsLoading] = useState(false)
//* Далее, добавляем его изменение в fetcPosts()
//* Перед тем как отправить запрос - true
//setIsPostsLoading(true)
//* Посл того, как запрос закончился снова false
//
//* в шаблоне (в ретерне в Арр) отрисовываем
//* над списком постов длаем условие
//* проверим {isPostsLoading ? <h1>Идет загрузка</h1> :  <PostList .../>}
//
//! Пополняем UI бибилотеку - Loader.jsx и Loader.module.css
//
//* и css файл для изолции стилей!!! там создаеся файл с уникальным номером
//
//*Пишем стили для крутилки
//  .loader {
//    width:100px;
//    height:100px;
//    border-radius: 50%;
//    border: 1px dshed peal
// }
//
//* и этот компонент вставлем в Арр в шаблон вместо Идет загрузка
//
///* пишем стили для крутилки 
//* Добавляем анимацию крутилке
//* В стилях пишем ключевые кадры для анимации
//* слово и название аниации
//? .loader {
//?    width: 100px;
//?    height: 100px;
//?    border-radius: 50%;
//?    border: 3px dashed teal;
//?    animation: rotate 1s infinite linear ;
//? }

//? @keyframes rotate {
//?    from {
//?       transform: rotate(0deg) scale(1);
//?    }
//?    to {
//?       transform: rotate(360deg) scale(1.4);
//?    }  
//? }
//
//*Зделали еще один компонент в UI библотеку
//* теперь 5 переиспользуемых компонентов!!
//
//! **** кастомный хук useFeching.js ***
//* 
//* показать , срыть крутилк после запроса
//* - обработка индикатора загрузки!!
//* - обработка колбэка!!
//* - обработка ошибки!!
//* - возврааем массив из 3х элементов и сможем его деструкторизировать подобным usesatet образом!!!!!
//* Этим массивом внутри любого компонента можем управлять как хотим!!
//
// import { useState } from "react"

// export const useFetching = (callback) => {
//       const [isLooading, setIsLoading] = useState(false);
//       const [error, setError] = useState('');

//       const fetching = async() => {
//          try {
//             setIsLoading(true)
//             await callback();
//          } catch (e) {
//             setError(e.message);
//          } finally {
//             setIsLoading(false)
//          }
//       }

// return [fetching, isLoading, error] - возврааем , чтобы деструкторизацией вызвать где надо, например в Арр
// }

//* идем в Арр
//* это нам состояние уже не нужно
//  const [isPostsLoading, setIsPostsLoading] = useState(false)
//* делаем деструкторизацию и вызываем useFetching
//* const [] = useFetching(async() =>{
//   юда переносим - получить посты с сервера и застить их в состояние
//})
//* это уже не нужно, все перенесли в useFetching выше
// async function fetchPosts() {
//    setIsPostsLoading(true)
//    const posts = await PostService.getAll();
//    setPosts(posts);
//    setIsPostsLoading(false)
// }
//* Вот чо в Арр:
// const [fetchPosts, isPostsLoading, postError] = useFetching(async() => {
//    const posts = await PostService.getAll();
//    setPosts(posts);
//   })
//
//* и функцию fetchPosts вызыва5ем уже в useEffect
//* а за показ индикатора отвечает хук

//!  ******   Пагинация - потраничный вывод*****
//
//* На 10 потов на странице
//*
//* Открываем jsonplaceholder и дабавляем пару query параметров
//* прямо через запяту после ура
//* {params:
//*   limit:_limit=10 - сколько постов на страниц
//*   page:_page - на какой сттранице
//}
//* в поисковой строке это выглядит так:
//* сначала ? - как разделитель урла и параметров, и указатель тогго, что дальше query параметры
//* & - разделитель параметров
//*https://jsonplaceholder.typicode.com/posts?_limit=10&_page=2

//* если зайти в консоле, открыть headers, 
//* то увидим x -total- count 100  - это общее кол-во страниц
//* на основании этого мы можем посчитать сколько надо постов на странице и получать посты частями
//* новую порцию данных при нажатии на страницву
//* В PostSevice добавляем квери параметры
//* А также будем возвращать сам response без data
//* так как надо будет обращаться к headers и вытаскиать общее кол-во посстов

//* а в Арр вместо posts в запросе будем получато response !!!!
//* и в посты мы будет сетить теперь поле data у response
//
//*Теперь создае состояние, в коорое мы будем помещать общее кол-во постов - 
//* const [totalCount и setTotlCount] = useState(0) - по умолчанию 0
//*вызываем функцию поле того как получили поле dta у респон
//* обащаемся к хедерам и получаем x-total-count
//setTotalCount(response.headers['x-total-count'])
//*пока, если посмотреть в консоле, то там undefined
//* потому что неуказали query параметры limit и page
//
//* поэтому в само сервисе указываем лимит=10 и номер страницы=1
//* и после урла через запятую передаем эти параметры
//* в Арр передаем эти параметры в функцию getAll(LIMIT, PAGE)
//* прежде создаем состояни для лимита и для номера страницы
//* инициализация - 10 и 1
//
//* теперь jsonpaceholder поймет, что мы хотим делать пагинацию и вернет x-total-count
//* сразу в логах мы получаем число 100 - это общее кол-во страниц
//* поделив число на лимит, получим кол-во страниц
//
//* в приложении может быть 10-15 разных компонентов, где будем реализовывать пагинацию
//* вынесем ее в отдельный блок
//* utils => pages.js (работа с датами, форматирование, работа со строками, с ол-вом страниц)
//* ункция аргументом будет принимать общее кол-во элементов и возвращать необходимое кол-во страниц
//* export const getPageCount = (totalCount, limit) => {
 //       retun Math.ceil(totalCount / limit) //округляем в большую строну
//}
//* если у насс будет больше 100 постов, то надо округить так, чтобы была 11 страница и на ней отобразить оставшиеся посты
//
//* состояние totalCount переименовываемв totalPages и хранить там общее кол-во страниц
//* и в запросе const totalCount = esponse.headers['x-total-count']
//* setTotalPages(gtPageCount(totalCount, limit))
//
//* pages.js^
// export const getPageCount = (totalCount, limit) => {
//    return Math.ceil(totalCount / limit)
// }
//
//* App
// const [fetchPosts, isPostsLoading, postError] = useFetching(async() => {
//    const response = await PostService.getAll(limit, page);
//    setPosts(response.data);
//    const totalCount = response.headers['x-total-count']
//    setTotalPages(getPageCount(totalCount, limit))
//   })
//
//* Теперь зная кол-во страниц, можем сформировать массив, в котором значчения идут от 1 до 10
//* И на основании этого массива нарисовать кнопки, при нажатии на которы будет меняться страница
// let pagesArray = []
// for (let i = 0; i < totalPages; i++) {
//     pagesArray.push(i + 1)
// }
//
//* теперь сделаем декомпозицию и вынесем  функционал по заполнению массива в отдельную ункцию
//* поместим ее таже в pages.js
//export const getPagesArray = (totalPages) => {
//    let res = [];
//    for (let i = 0; i < totalPages; i++) {
//        res.push(i + 1)
//    }
//    return res;
// }
//
//* App:
//let pagesArray = getPagesArray(totalPages);
//
//* Теперь отрисуе кнопки
//* у нас есть массив pagesArray, мы с помощью map по нему итерируемся (в етерне, в Арр)
//* и для аждого элемента создаем кнопку и внутрь кнопки помещаем номер страницы
// {pagesArray.map(p => 
//    <span 
//       onClick={() => setPage(p)}
//       key={p} 
//       className={p === page ? 'page page__current' : 'page'}
//    >
//        {p}
//    </span>}
//
//* реализовали смену страниц, еперь ужно реализовать подгрузку новых данных
//* есть 2 варанта - useEffect() и в массив зависимости добавить номер страницы
//* либо создать ф-ю, которая будет изменять номер страницы и с измененным 
//* номером страницы одгружать новую порцию данных
//
// const changePage = (page) => {
//    setPage(page)
// }
//  <div className="page__wrapper">   
// {pagesArray.map(p => 
//    <span 
//       onClick={() => changePage(p)}
//       key={p} 
//       className={p === page ? 'page page__current' : 'page'}
//    >
//        {p}
//    </span>
// )} 
//
//* после изменения ноера страницы надо вызвать ф-ю fetchPosts
// const changePage = (page) => {
//    setPage(page)
//    fetchPosts()
// }
//
//* Но зесь будут некоторые проблемы - посты будут отставать
//
//* фетчпост использует внутри себя состояния - лимит и пейдж
//* и мы сначала это состояние изменяем, а затем вызываем функцию фетчпост
//* изменение состояния - это асинхронный процесс
//* и там происходят каки-то изменения, сад эффекты - реакт накапливает измеения и именяет пачкой
//* Реакт применяет изменения разом!! чтобы избежать манипуляции с ДОМ
//*  Мы состояние изменили, вызвали fetchposts, но при 
//* этом там замкнуто состояние старое
//* и получается так, что page попадает в запрос с некоторым отставанием
//
//* Пэтому используем 1й способ с useEffect - в массив зависимостей добаить page
//
//* Таким образом UseEffect будет слдить за изменением старницы и ы будем получать нужные данные!
//*
//* PostItem  props.number меняем на props.post.id чтобы при переходе по страницам 
//* посты менялись и получали свой порядковый номер, а не каждый раз с 1
//
//
//! **** Настраивае Роутинг ****
//
