//* --*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
//* Услоная отрисовка:
// {sortAndSearchPosts.length !== 0
//    ? <PostList remove={removePost} posts={sortAndSearchPosts} title="Список постов по JavaScript"/>
//    : <h1 style={{textAlign: 'center'}}>Посты не найдены!</h1>
//  }      

//* получаем данный из управляемого инпута:
// const[title, setTitle] = useState('');
// const[body, setBody] = useState('');


//* инпутов может быть много - создаем состояние post и помещаем туда объект с title и body
//* инициализируем их сразу пустыми строками
//* а в onChange - передаем объект в setPost - разворачиваем тарые посты и перезатераем нужное для насс поле
//* то есть. еще раз, мы изеняем нужное для нас поле, а весь остальной объек оставляем в неизменном виде
//* добавим id - он должен быть всегда уникальный - егополучим из текущей даты!!
//* e.preventDefault(); //проедотвращаем дефолтное поведение браузера(когда при нажатии на кнопку страница оновляетсяя и данные уходят на сервер, так как тип у кнопки submit)
//   const newPost = { - эта переменная теперь не нужна - разворачивае в setPosts вместо newPost развернем ...post, и добавим id
//      id: Date.now(), - 
//      title,
//      body,
//   }

     //!  ***   запомнить НАВСЕГЛА  - важно!! - добавление нового поста - развернуть старый массив и добавить новый пост
   //   setPosts([...posts, {...post, id: Date.now()}]) // добавляем ссозданный объект в массив постов - не изменем состояние напрямую, вызываем setPosts и передаем туда новый массив [], куда разворачиваем старый массив с постами и добавяем новый ерез запятую
   //   setTitle('') // после добавление очиаем поле ввода в инпуте для тайтла
   //   setBody('') // после добавление очиаем поле ввода в инпуте для боди
   //   setPost({title:'' , body: ''}) // теперь очищение формы после добавления посста так делаем
//* и так как мы реализоали двустороннее связывание, то инпуты при таком повдении у нас очистятся - компонент управляяемы
//
//* Так ниже мы будем проверять, если постов нет - длины постов нет - то мы будем выводить надпись - ПОСТЫ не найдены!


//*-----------------------------------------------------
//* Создаем функцию сортировки sortPosts чтобы вызвать ее в onChange
//* но мы не можем напрямую сортировать, так как метод сорт мутирует исходный массив
//* поэтому , мы разворачивае с помощь spread исходный массив постов, а таким образом мы его копируем
//* и сортируем уже копию
//* для сравнения строк используетс localeCompare()
//* setPosts([...posts].sort(a,b) => a[sort].locleCompare(b[sort]))
//* сравниваем поле из объекта а с полем из объекта b
//* Реализуем поиск searchQuery в MyInput
//* Для того чтобы удалять ненужные
//* При этом нужно реализовать фильтрацию !!
//* Механизм сортировки переносится в const sortedPosts
//*[...posts].sort((a,b) => a[sort].localeCompare(b[sort])))
//* но там уже не просто sort используем, а само состояние selectedSort
//* и в компонент PostList будем передавать не просто ссостояние
//* а уже отсортированный массив постов - эту функцию sortedPosts
//
//* так как selectedSort  - это пустая строка, то подобная соритировка не отработает
//* так как мы оращаемся к пустому полю и выдаст undwfined 
//* мы пытаемся получить несуществующщее поле и вызываем у его ф-ю localeCompare()
//* а этого поля нет, мы получаем undefined, и соответствено пытаемся вызвать ф-ю у андефайнед
//
//* поэтому надо создать ф-ю - getSortedPosts() - и проверять
//* если selectedSort существует , если там не пустая строка
//* то мы будем возвращать отсортированны массив
//* в обратном случае просто массив постов posts
//* а в ф-ю sortedPosts мы помещаем результат getSortedPosts
//* функция sortedPosts отрабатывает
//* но если что-то написать в инпут, то на каждый ввод символа эта функция вызывается
//* на каждый рендер
//* такое нас не устраивает, если массив состоит из 1000 элементов, то это жуткий удар попроизводительности
//
//* ПОЭТОМУ!!! 
//! *** useMemo(callback, deps) **
//*колбэк должен возвращать результат каки-то выислний
//*например, отсортированный или отфильтрованный массив, какие-то математич вычисления
//* в массив зависимостей передавать переменные, поля объекта
//useMemo(() => {
//    return [...posts].sort(...)
// }, [selectedSot, posts])
// Для его это хук?
//* Производит вычисление, запоминает результат и кеширует!
//* Это называется Мемоизация
//* И на каждую перерисовку компонента, она не ортирует массив вновь, пересчитывает заново
//* Достает отсортированный массив из кеша
//* Но каждый раз когда какая-либо из зависимотей менятся
//* Например, мы выбрали другой режим сортировки - функци вновь персчитывает и кеширует новый результат
//* До тех пор, пока опять одна из зависимостей не изменится
//* Если массив зависимостей путой. то функция отработает лишь единожды. запомнит результат и болье вызвана ен будет!!!
//* кобэ будет взван в том случае, когда какая-то из зависимостей поменяет значени
//
//!  **** Реализуем поиск! *** sortAndSearhPosts - 
//* на основании отсортированного массива мы и можем деать поиск!
//
//* useMemo() - в массв заисимостей будет попадать поисковая строка и отсортированный массив
//* [seachQuery, sortedPosts]
//* Сейчас в компоннт POstList будем передавать и отсортированный и отфильтрованный массив sortAndSearchPosts
//* то есть, одовременно будет работать и поиск и сортировка
//* из колбэка внутри UseMemo мы долны вернуть результат каких-либо вычислений
//* здесь мы должны отфильтровать массив по поисковой строке - есть там что-то или нет
//* выделяем каждый пост, поле title.includes(seachQuery)
//* то есть вводим в поисковик необходимый пост, а он нам показывает есть среди постов такой или нет
//*
//*Реализовала поиск - с фукцией toLowerCase() тобы игнорировать регистр
// const sortAndSearchPosts = useMemo(() => {
//    return sortedPosts.filter((post) => post.title.toLowerCase().includes(searchQuery.toLowerCase()))
// }, [searchQuery, sortedPosts])
//
//* Если по поиску ни одного посста не находится, должна появляться надиссь - посты не надены
//* поэтому, услови для такой надписи надо делать дл sortAndSearchPosts.length
//* если есть, то делать отрисовку PostList
//* если нет. то надпиь - посты не найдены!
//
//!  PostFilter.jsx - отвечает за манипулции над списком постов
//* Будет отвечать за сортировки, за фильтрации
//* помимо поиска модно придумать еще кучу фильтров, все сюда
//* Далее декомпозиция - выделение сортировки и фильтрации в PostFilter()
//* и в него идет сортировка и поиск MyInput MySelect
//
//*создали PostFilter и создаем в Арр новое состояние [filter, setFilter]
//* вместо этого, что ниже
// //*создаем состояние для сортировки
// const [selectedSort, setSelectedSort] = useState('');  

// //*делаем MyInput дл поиска постов управляемым
// const[searchQuery, setSearchQuery] = useState('')
//
//* const[filter, setFilter] = useState({sort: '', query:''})
//* sort - алгоритм сортировки
//* query - поисковая строка
//
//* При этом, состояни selectedSort и seachQuery удаляем и заменяем на filter
//* Инициализируя его объектом ({sort:'', query:''})
//* И поскольку состояния selectedSort и seachQuery удалили,
//* внесем правки и заменим их в колбэках у  useMemo() на filter.sort и filter.query
//
//* Функция для получения постов и проверка, есть ли они, тогда сортировка
//
// const sortedPosts = useMemo(() => {
//    if(filter.sort) {
//      return [...posts].sort((a, b) => a[filter.sort].localeCompare(b[filter.sort]))
//    } else {
//       return posts
//    }
// }, [filter.sort, posts])

// const sortAndSEarchPosts = useMemo(() => {
//    return sortedPosts.filter((post) => post.titile.toLowerCase().includes(filter.query.toLowerCase()))
// }, [filter.query, sortedPosts])
//
//* Сейчас есть форма для создания, для фильтрации и список
//
//! Это называетс Услова отрисовка!!
// {posts.length - длина постов есть(посты есть)
//    ? <PostList remove={removePost} posts={posts} title="Список постов по JavaScript"/>
//    : <h1 style={{textAlign: 'center'}}>Посты не найдены!</h1>
//  }
//
//*переносим условную отрисовку в сам список постов <PostList />
//
//! **** Всплывающее Модальное окно  ****
//
//* Переносим форму для создания поста в модальное окно


//*!  *** Анимация - react-transition-group 
//* устанавливается пакет
//* например, сдлеать. чтобы посты заезжали и выезжали
//npm install react-transition-group --save
//* можно реанимировать списки, отслеживать фазы анимации
//
//* Открываем PostList и завернем его в TransitionGroup
//
//! ** переходим к кастомным хукам!
//* логику по сортировки и фильтации выносим в usePosts.js
//* кастомные хуки всегда начинаются с use и расширение имеют js
//* сразу экспортируются
////* сортировка с состоянием - переносится в кастомный хук usePosts.js
// const sortedPosts = useMemo(() => {
//    console.log('отработала функция сортед постс')
//    if(filter.sort) {
//       return  [...posts].sort((a,b) => a[filter.sort].localeCompare(b[filter.sort]))
//    } else {
//      return posts;
//    }
// },[filter.sort, posts])

//* Логика переносится в катомный хук usePosts!!^::
// const sortAndSearchPosts = useMemo(() => {
//     return sortedPosts.filter((post) => post.title.toLowerCase().includes(filter.query.toLowerCase()))
// }, [filter.query, sortedPosts]
//* Кастомные хуи - это хуки, которые на верхнем уровне
//* испольльзуют сандартные реакт хуи(useState, useMemo)
//* export const useSortedPosts = (posts, sort)=>{} - параметрами будет ринимать посты и метод ссортировки
//
//* Логика готова уже - это вся логика с useMemo!!
//* берем ее из Арр и переносим in usePosts
//* так как функция принимает sort, то filter уже не нужен
//? const sortedPosts = useMemo(() => {
//?    console.log('отработала функция сортед постс')
//?    if(filter.sort) { //sort
//?       return  [...posts].sort((a,b) => a[filter.sort].localeCompare(b[filter.sort])) // и здесь просто sort
//?    } else {
//?      return posts;
//?    }
//? },[filter.sort, posts]) //sort

//* по итогу у нас есть хук, коорый что-то сортирует и по итогу отсортированный массив должен вернуть
//
//* Хук по сортировки готов:
// import { useMemo } from "react";

// export const useSortedPosts = (posts, sort) => {
//    const sortedPosts = useMemo(() => {
//       console.log('отработала функция сортед постс')
//       if(sort) {
//          return  [...posts].sort((a,b) => a[sort].localeCompare(b[sort]))
//       } else {
//         return posts;
//       }
//    },[sort, posts])

//    return sortedPosts;
// }
//
//* Ниже создаем еще один - usePosts - он будет возвращать уже и отфильтрованный, и отортированный массив постов
//
// export const usePosts = (posts, sort, query) => {
//    //* получим масив отсортированных постов:
//    const sortedPosts = useSortedPosts(posts, sort)

//    const sortAndSearchPosts = useMemo(() => {
//       return sortedPosts.filter((post) => post.title.toLowerCase().includes(query.toLowerCase()))
//   }, [query, sortedPosts])
  
//    return sortAndSearchPosts;
// }

//
//* таким образомб получился хук usePosts.js, который и сортирует и фильтрует
//* осталось вызвать его внутри компонента Арр
//* а в Арр сделали декомпозицию и логику вынесли, стало меньше на 15 строчек кода

//*Стили для модального окна
// .myModal {
//    position: fixed;
//    lft:0;
//    right:0;
//    bottom:0;
//    top:0
//    display:none
//    background: rgba(0,0,0, 0.5)
// }

// myModal.content{
//    padding:25px;
//    background: white;
//    border-radius: 16px;
//    min-width: 250
// }

// .myModal.active {
//    display:flex;
//    jcsb  
//    aic
// }

//import cl from "./MyModal.module.css"
// const MyModal = ({children, visible, setVisible}) => {

//    const root = [cl.myModal]
//    if(visible) {
//       root.push(cl.active)
//    }

//    return(
//       <div className={root.join(' ')} onClick = {() => setVisible(false) }>
//          <div classNme={cl.myModalContent} onClick={(e) => e.stopPropagation()}>
//             {children}
//          </div>
//       </div>
//    )
// }
//
// App
//
// Состояние - видимо модальное окно или нет
// const [modal, setModal] = useState(false)

// <MyButton style={{marginTop: 30}}onClick={() => setModal{true}}>
//    Добавить пост
// </MyButton> 
// <MyModal 
//  visible={modal}
//  setVisible={setModal}
// >
 //  <PostForm create={createPost} />
//</MyModal> 
//*
//* Чтобы закрывалась модалка после добавления поста
//* в createPost добавить setModal(false)
// const createPost = (newPost) => {
//    setPosts([...posts, newPost])
//    setMdal(false) //сетим в остояние false
// }

//! ****   работа с серверо AXIOS  ***
//
//* jsonplaceholder.typicode.com
//* JSON{Placeholder} - позволяет получать некоторое кол-во данных
//* то еть . мы отправляем запро и получаем объекты, массивы
//* есть наор эндпоин - адресов, с пом которых мы получаем данные
//* нас интересуют посты
//* в разделе Resources 
// https://jsonplaceholder.typicode.com/posts
//* копируем эту ссылку 
//*идля того, чтобы делать запросы, понадобится библтотека axios
//* npm i axios
//* устанавливаем
//* теперь реализуем функцию. котора будет отправлять запрос на сервер, 
//* получать данные и помещать их в состояние с постами
//* вместо fetch используем axios !!!! - это у нас get запрос
// async function fetchPosts () {
//    const response = await axios.get('https://jsonplaceholder.typicode.com/posts')
//    setPosts(response.data)
// }
// <yButton onMCliick={fetchPosts}>Get Post</yButton>
// по нажатию на кнопку в консоле
//{data: Array(100), status: 200, statusText: '', headers: AxiosHeaders, config: {…}, …}
//нас итересует как раз 100 постов
//* консоль убираем и помещаем результат с постами в состояние
//* добавили резал  setPosts(response.data)
//* нажимаем на кнопку getpost и загружаютс на странице все 100 постов
//* 
//* сейчас мы подгружаем посты принажатии на кнопку
//* а надо. чтобы они сами подгружались при первичной отрисовки приложения
//
//! *** хук useEffect(callback, dept) ***
//
//* Наблюдает за жизненым циклом компонента
//
//* Жизненный цикл компонента:

//* Монтирование(mount) - создается компонент и вмонтируется в дом дерево
//* - первичная подгрузка данных
//* - повесить какие-то слушатели события
//
//* Обновление(update) - стадия активной жизни компонента - изменили состояние - происходит апдейт
//* - следить за изменениями каких-либо зависимостей
//* -

//* размонтирование(unmount) -
//*- очищение глобального хранилища, 
//* - отписывание от событий
//
//* useEffect используетс в одном компоненте сколько надо 
//* один хук за первичную отрисовку, другой за изменениями, третий за удалением
//
//* Стадия монтирования:
//* При первичной загрузке массив зависимости пустой,
//* колбэк отработает лишь единожды и больше вызвани не будет
//* посты подгузутся
//
//* Стадия обновления:
//* Чтобы следить за изменениями, нужно добавить объекты в массив зависимости
//* мы будем следить за объектом filter, и какждый раз. когда он изменяестя, будет отрабатывать колбэк, который мы передали в useEffect()
//
//* Стадия размонтирования:
//* Если колбэк возвращает какую-либо функцию, то она вызовется в момент демонтирования компонента 
//* Очистки, отписки и тд

// const getPosts = useEffect(() => {
//    fetchPosts()
// }, [])
//
//* Далее, делаем ручку. за котрую можно дернцть и полуить массив постов
//
//*!  ****   Создаем папку API ***
//* в ней PostService.js
//
//* вынесем получение постов в отдельный файл!!
//* создадим клас и в ней татичная асинхронная функция, 
//* которая будет возвращать список постов
//* и переносим запрос в axios.get в нее
//* и по итогу из этой функции будем возвращать массив посто retun response.data
//* можно отловить ошику, но подже изменим - на уровне сервера делать это не хорошо
// export default class PostService {
//    static async getAll(){
//        const response = await axios.get('https://jsonplaceholder.typicode.com/posts')
//        return response.data;
//}
// }
//* в Арр в функции fetchPosts вместо axios.get обращаемся к PostService.getAll()

//
//*! *****  isPostsLoading **** индикатор загрузки - крутилка
//
//* Создаем состояние и по умолчанию оно false
//const [isPostsLoading, setIsPostsLoading] = useState(false)
//* Далее, добавляем его изменение в fetcPosts()
//* Перед тем как отправить запрос - true
//setIsPostsLoading(true)
//* Посл того, как запрос закончился снова false
//
//* в шаблоне (в ретерне в Арр) отрисовываем
//* над списком постов длаем условие
//* проверим {isPostsLoading ? <h1>Идет загрузка</h1> :  <PostList .../>}
//
//! Пополняем UI бибилотеку - Loader.jsx и Loader.module.css
//
//* и css файл для изолции стилей!!! там создаеся файл с уникальным номером
//
//*Пишем стили для крутилки
//  .loader {
//    width:100px;
//    height:100px;
//    border-radius: 50%;
//    border: 1px dshed peal
// }
//
//* и этот компонент вставлем в Арр в шаблон вместо Идет загрузка
//
///* пишем стили для крутилки 
//* Добавляем анимацию крутилке
//* В стилях пишем ключевые кадры для анимации
//* слово и название аниации
//? .loader {
//?    width: 100px;
//?    height: 100px;
//?    border-radius: 50%;
//?    border: 3px dashed teal;
//?    animation: rotate 1s infinite linear ;
//? }

//? @keyframes rotate {
//?    from {
//?       transform: rotate(0deg) scale(1);
//?    }
//?    to {
//?       transform: rotate(360deg) scale(1.4);
//?    }  
//? }
//
//*Зделали еще один компонент в UI библотеку
